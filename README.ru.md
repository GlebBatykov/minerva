<div align="center" width="200px">

<img src="https://raw.githubusercontent.com/GlebBatykov/minerva/main/doc/images/logo.png" width="150px"/>

&nbsp;

Фреймворк для создания многопоточного REST API сервера

</div>

<div align="center">

[![pub package](https://img.shields.io/pub/v/minerva.svg?label=minerva&color=blue)](https://pub.dev/packages/minerva)

**Языки:**
  
[![English](https://img.shields.io/badge/Language-English-blue?style=?style=flat-square)](README.md)
[![Russian](https://img.shields.io/badge/Language-Russian-blue?style=?style=flat-square)](README.ru.md)

</div>

- [Введение](#введение)
- [Про Minerva](#про-minerva)
- [Экосистема](#экосистема)
- [Установка](#установка)
- [Консольная утилита](#консольная-утилита)
  - [Создание проекта](#создание-проекта)
  - [Сборка проекта](#сборка-проекта)
  - [Запуск проекта](#запуск-проекта)
  - [Отладка проекта](#отладка-проекта)
    - [VS Code](#vs-code)
  - [Тестирование](#тестирование)
  - [Docker](#docker)
- [Конфигурирование проекта](#конфигурирование-проекта)
- [Структура фреймворка](#структура-фреймворка)
  - [Компоненты](#компоненты)
- [Маршрутизация](#маршрутизация)
  - [Конвейер](#конвейер)
  - [Конечные точки](#конечные-точки)
    - [Api](#api)
    - [Тело запроса](#тело-запроса)
      - [FormData](#formdata)
    - [Параметры пути](#параметры-пути)
    - [Фильтр запроса](#фильтр-запроса)
    - [Веб-сокеты](#веб-сокеты)
- [Аутентефикация](#аутентефикация)
  - [JWT](#jwt)
  - [Куки](#куки)
- [Промежуточные обработчики](#промежуточные-обработчики)
  - [Готовые промежуточные обработчики](#готовые-промежуточные-обработчики)
  - [Создание собственных промежуточных обработчиков](#создание-собственных-промежуточных-обработчиков)
- [Статические файлы](#статические-файлы)
- [Внедрение зависимостей](#внедрение-зависимостей)
- [Агенты](#агенты)
  - [Создение собственных агентов](#создение-собственных-агентов)
- [Логирование](#логирование)
  - [Конвейер](#конвейер-1)
  - [Готовые логеры](#готовые-логеры)
    - [Шаблоны логирования](#шаблоны-логирования)
    - [Логирование в файлы](#логирование-в-файлы)
  - [Конфигурация логирования](#конфигурация-логирования)
  - [Создание собственных логеров](#создание-собственных-логеров)
- [Менеджер конфигурации](#менеджер-конфигурации)
- [Хэширование паролей](#хэширование-паролей)
- [Дорожная карта](#дорожная-карта)
- [Благодарность](#благодарность)

# Введение

Я решил занятся написанием собственного серверного фреймворка по причине того что в Dart большинство крупных серверных фреймворков перестали поддерживаться (`Aqueduct`, `Angel` и другие).

При создании фреймворка я хотел чтобы он работал как с `JIT` так и с `AOT` типом компиляции, то есть он не должен был использовать `dart:mirrors`, что сильно повлияло на реализацию многих вещей. Я не исключаю в дальнейшем написания отдельных пакетов для экосистеме этого фреймворка, которые будут базироваться на `dart:mirros` или на `build_runner`. Но если они будут базироваться на `dart:mirros`, они будут выступать в качестве отдельных пакетов, а не входить в основной фреймворк.

В других серверных фреймворках мне нравилось наличие в проекте конфигурационных файлов, а так же системы сборки (от части я вдохновлялся ASP.NET). Поэтому в этом фреймворке присутствует система сборки проекта, и несколько режимов сборки: `debug` и `release`. Так же в рамках каждой сборки вы можете выбрать тип компиляции: `JIT` или `AOT`. Вместе с пакетом поставляется `CLI` утилита для этого.

В поставляемой `CLI` утилите так же присутствует возможность генерации `docker` файла, что мне показалось удобной вещью.

Я создавал этот фреймворк с расчетом на то чтобы выжать максимум пользы от использования изолятов при обработке запросов. Так же я попытался решить проблемы, с которыми можно столкнутся при использовании изолятов при построении сервера.

Многие компоненты фреймворк, такик как промежуточные обработчики запросов, средства для журналирования и другие компоненты, допускают написание собственных, пользовательских компонентов под ваши нужды.

Пишите мне свое мнение по поводу этого фреймворка, сообщайте об ошибках или неточностях, нелогичностях. Я очень хочу знать ваше мнение.

# Про Minerva

`Minerva` это фреймворк для создания многопоточного REST API.

`Minerva` предоставляет:

- систему сборки проекта;
- многопоточную обработку запросов;
- маршрутизацию запросов, обработку запросов при помощи промежуточных обработчиков;
- возможности логирования, создания собственных логеров;
- предоставляет средства для аутентификации по JWT, кукам;
- средства для раздачи статических файлов;
- работу с `FormData`;
- возможность генерации Docker файла;
- и другое.

# Экосистема

Различные пакеты для упрощения работы с `Minerva`, а так же в целом которые упрощают написание серверных приложений на `Dart`, вероятно, будут выходить в качестве отдельных пакетов.

Существующие в данный момент мои пакеты, которые могут вам пригодится:
  - [emerald](https://pub.dev/packages/emerald) - `JSON` сериализатор/десериализатор, основан на `dart:mirros`, работает только с `JIT` типом компиляции.

# Установка

Установите `Dart`.

Установите `Minerva`:

```dart
dart pub global activate minerva
```

Создать проект и запустить пример:

```dart
minerva create -n my_application

cd my_application

minerva run
```

# Консольная утилита

Фреймворк содержит `CLI` утилиту `Minerva`, которая содержит следующие команды:

- `create` - создает проект с стандартным шаблоном;
- `build` - выполняет сборку проекта, в соответствии с текущими параметрами заданными в appsetting.json файле проекта;
- `clear` - очищает сборку проекта;
- `run` - запускает проект, если сборка проекта отствует, то предварительно запускает сборку;
- `debug` - выполняет запуск проекта с сервисами `VM` для отладки, тип компиляции запускаемой сборки должен быть `JIT`;
- `test` - запускает сервер, запускает тесты, после выполнения тестов завершает процесс сервера;
- `docker` - генерирует `Dockerfile`.

## Создание проекта

Для создания проекта с стандартным шаблоном в `CLI` утилите `Minerva` содержится команда `create`.

Команда содержит обязательный параметр `name`, который указывает имя создаваемого проекта.

При помощи параметра `directory` вы можете задать директорию создания проекта.

При помощи параметров `debug-compile-type` и `release-compile-type` вы можете указать типы компиляции для `debug` и `release` типов сборки проекта. Вы сможете изменить их в любой момент в `appsetting.json` файле.

При помощи параметра `docker-compile-type` вы можете указать тип компиляции для которого будет генерироваться `Dockerfile`. Вы можете в любой момент сгенерировать `Dockerfile` заново при помощи команды `docker`.

## Сборка проекта

Сборка проекта в `Minerva` предполагает наличие двух типов сборки проекта:

- `debug` - для отладки и разработки проекта;
- `release` - для конечного развертывания.

При создании проекта в его корне создается файл `appsetting.json`. Это основной конфигурационный файл проекта.

## Запуск проекта

Запуск проекта осуществляется при помощи команды `run`, а так же запустив исполняемый файл в папке /build/`тип сборки`/bin (для `JIT` компиляции это `kernel snapshot`, а для `AOT` это `exe` файл) вручную. При разработке предпочтительней запускать проект при помощи команды `run`, так как она предполагает так же автоматическую сборку проекта.

## Отладка проекта

Отладка доступна только с использованием `JIT` компиляции. Для запуска приложения в режиме отладки используется команда `debug`.

### VS Code

Для запуска отладки в редакторе VS Code вы должны создать файл `launch.json` и указать в `configurations` параметр `program`. В параметре `program` вы указываете путь к исполняемому файлу. Для `JIT` компиляции `Minerva` создает `kernel snapshot`, он хранится по пути build/`тип сборки`/bin/main.dill. Пример пути: `build/debug/bin/main.dill`.

## Тестирование

Запуск тестирования осуществляется при помощи команды `test`. Тестирование предполагает запуск сервера, выполнение всех тестов, завершение процесса сервера.

При сборке проекта в папке `test` генерируется файл `test_app_setting.g.dart`. В нем хранятся порт и адрес, которые использует сервер при текущей сборке. Это сделанно для удобства, чтобы вы могли при старте тестов получать доступ к актуальным для текущей сборки проекта настройкам из файла `appsetting.json`.

## Docker

При создании проекта при помощи команды `create` генерируется `Dockerfile` для заданного типа компиляции.

Для разных типов компиляции докер файлы отличаются. Есть 2 шаблона докер файлов:

- `JIT`;
- `AOT`.

Вы можете в любой момент заново сгенерировать докер файл с выбранным типом компиляции при помощи команды `docker`. Тип компиляции задается параметром `compile-type`, по умолчанию это `AOT`.

При генерации докер файла так же учитываются добавленные в конечную сборку проекта ассеты из файла `appsetting.json`. Поэтому после их добавления вы должны либо сгенерировать `Dockerfile` заново, либо отредактировать `Dockerfile` вручную.

# Конфигурирование проекта

Каждый `Minerva` проект содержит конфигурационный файл `appsetting.json`. Этот файл содержит настройки для `debug` и `release` сборок проекта, а так же позволяет внедрять значения и произвольные файлы в конечную сборку проекта.

Файл `appsetting.json` содержит поля `debug` и `release`, в которых содержаться детали конфигурации соответствующих сборок проекта.

В них вы можете конфигурировать:

- `host` - адрес на котором запускается сервер. По умолчанию для `debug` это `127.0.0.1`, а для `release` это `0.0.0.0`;
- `port` - порт на котором запускается сервер. По умолчанию для `debug` это `5000`, а для `release` это `8080`;
- `compile-type` - тип компиляции проекта. Может быть либо `JIT`, либо `AOT`;
- `values` - значения внедряемые в сборку. Получить к ним доступ можно при помощи [менеджера конфигурации](#менеджер-конфигурации);
- `logging` - конфигурация логирования. Подробней о ней можно прочитать [тут](#конфигурация-логирования).

Так же `appsetting.json` может содержать общие настройки, для всех типов сборки проекта:

- `values` - значения внедряемые в сборку. Получить к ним доступ можно при помощи [менеджера конфигурации](#менеджер-конфигурации);
- `assets` - при помощи указания ассетов вы можете внедрить произвольные файлы в сборку проекта. Путь к ним задается относительно папки проекта.

Пример указания списка ассетов:

```dart
"aseets": [
  "/wwwroot",
  "some_file.txt"
]
```

# Структура фреймворка

Структура `Minerva` создавалась с учетом возможности обработки запросов в многих изолятах, для повышения производительности. Многопоточная обработка запросов реализованна при помощи запуска экземпляра сервера в нескольких изолятах, с использования параметра `shared` класса `HttpServer` из библиотеки `dart:io`.

Структура сервера может быть представлена так:

<div align="center">
  <img src="https://raw.githubusercontent.com/GlebBatykov/minerva/main/doc/images/server_structure.png" width="75%"/>
</div>

При помощи параметра `instance` класса `MinervaSetting` вы можете задать количество изолятов в которых будут запущены экземпляры сервера.

Изоляты используемые сервером делятся на 2 типа:

- `экземпляры сервера`;
- `агенты`.

Если с экземплярами сервера все понятно, это изоляты где запускается экземпляр сервера, то что такое агенты?

Запуск экземпляров сервера в разных изолятах накладывает некоторые ограничения и неудобства. К примеру у вас есть подключение к базе данных, но если мы запускаем сервер в нескольких изолятах тогда каждый из запущенных экземпляров сервера должен иметь собственное подключение. Это может быть не всегда удобно, могут быть разные сценарии использования чего либо такого. Или к примеру мы должны иметь некое общее состояние между всеми `экземплярами сервера`. Поэтому в `Minerva` есть агенты.

`Агент` - это отдельный изолят, который может хранить некое состояние, принимает сообщения с некими действиями, которые он может исполнять.

Все экземпляры сервера могут обращаться к одному `агенту`, взаимодействовать с ним.

Тогда схема работы сервера может быть представлена так:

<div align="center">
  <img src="https://raw.githubusercontent.com/GlebBatykov/minerva/main/doc/images/server_structure_with_agent.png" width="75%"/>
</div>

Конечно то что `агент` исполняется в отдельном изоляте бьет по производительности, из за потерь на передаче сообщений между изолятами. Однако он может быть полезным инструментом, в специфичных сценариях.

Подробнее об агентах вы можете прочитать [тут](#агенты).

## Компоненты

В процессе конфигурации сервера вы можете задавать промежуточные [обработчики запросов](#промежуточные-обработчики), [логгеры](#логирование), [api](#api). Все они называются компоненты. 

`Компоненты` - это сущности, имеющие свой жизненный цикл.

К компонента относятся:

- `промежуточные обработчики`;
- `логгеры`;
- `api`.

Из их жизненного цикла можно выделить наличие метода `initialize`, который отвечает за отложенную инициализацию. В процессе конфигурирования сервера вы создаете экземпляры компонентов и передаете их Minerva. Однако фактически экземпляры сервера работают в других изолятах, а Send/Receive порты налагают ограничения на передачу некоторых типов данных между изолятами. Поэтому в `компонентах` существует метод `initialize`, которые срабатывает уже после передачи их в конкретные изоляты, где они будут использоваться.

Отложенная инициализация может использоваться для открытия подключения к некому внешнему источнику. К примеру это может быть кастомный логгер, который отсылает логи на другой сервер и он должен при старте сервера инициализировать подключение.

# Маршрутизация

В `Minerva` маршрутизация запросов строится на конвейерной обработке запросов. При конфигурировании сервера задаются промежуточные обработчики, которые участвуют в процессе обработки поступившего запроса. Дательней об промежуточных обработчиках вы можете прочитать [тут](#промежуточные-обработчики).

Маршрутизация запросов в `Minerva` может быть представлена так:

<div align="center">
  <img src="https://raw.githubusercontent.com/GlebBatykov/minerva/main/doc/images/routing.png" width="75%"/>
</div>

## Конвейер

Конвейер обработки запросов состоит из промежуточных обработчиков. В этом разделе будут приведены лишь некоторые из них, об остальных, а так же о способе создания собственных промежуточных обработчиков вы можете прочитать [тут](#промежуточные-обработчики).

Схема работы конвейера обработки запросов может быть представлена так:

<div align="center">
  <img src="https://raw.githubusercontent.com/GlebBatykov/minerva/main/doc/images/middlewares_pipeline.png" width="75%"/>
</div>

## Конечные точки

Для обработки запросов используются конечные точки. Каждая конечная точка имеет свой адрес. Обработички конечных точек возвращают `dynamic`. 

Конфигурирование конечных точек осуществляется при помощи классов производных от класса MinervaEndpointsBuilder.

Существует несколько сценариев того как `Minerva` интерпретирует результат конечной точки перед отправлением ответа:

- если вы вернули `Map<String, dynamic>` то `Minerva` отправит ответ с кодом `200` и интерпретирует ваш ответ как `json`;
- если вы вернули экземпляр класса `Result`, то `Minerva` отправит ответ с настройками указанными в экземпляре `Result`;
- если вы вернете любой другой тип, то `Minerva` приведет его к строке (при помощи метода `toString`) и отправит ответ с кодом `200`.

`Result` это вспомогательный класс, для конфигурирования кода ответа, его заголовков и тела. `Minerva` содержит готовые шаблоны результатов:

- `OkResult` - отправляет ответ с кодом `200`;
- `BadRequestResult` - отправляет ответ с кодом `400`;
- `UnauthorizedResult` - отправляет ответ с кодом `401`;
- `InternalServerErrorResult` - отправляет ответ с кодом `500`;
- `JsonResult` - подразумевает отправку `json`, по умолчанию имеет статус код `200`;
- `NotFoundResult` - отправляет ответ с кодом `404`;
- `FileResult` - подразумевает отправку файла на скачивание;
- `FilePathResult` - подразумевает отправку файла на скачивания, позволяет указывать путь к файлу. Путь к файлу может быть задан как абсолютно, так и относительно папки проекта;
- `FileContentResult` - подразумевает отправку содержимого файла;
- `FilePathContentResult` - подразумевает отправку содержимого файла. Путь к файлу может быть задан как абсолютно, так и относительно папки проекта;
- `RedirectionResult` - отправляет ответ с кодом `301` и ресурсом куда необходимо перенаправить запрос.

Пример использования класса MinervaEndpointsBuilder для конфигурирования конечных точек:

```dart
class EndpointsBuilder extends MinervaEndpointsBuilder {
  @override
  void build(Endpoints endpoints) {
    endpoints.get('/hello', (context, request) {
      return 'Hello, world!';
    });
  }
}
```

Одним из поставляемых вместе с `Minerva` промежуточных обработчиков является `EndpointMiddleware`, этот обработчик должен быть последним в конвейере. Именно он отвечает за сапоставление входящего запроса с заданными конечными точками.

### Api

Конфигурирование конечных точек по отдельности, может быть не удобным, если конечные точки должны иметь некий общий контекст. В качестве общего контекста могут быть зависимости, которые вы задали при помощи инъекции зависимостей.

`Api` - это совокупность конечных точек, с неким общим контекстом. Их конфигурирование осуществляется при помощи классов производных от класса MinervaApisBuilder.

Пример создания HelloApi, использования класса MinervaApisBuilder для конфигурирования api:

```dart
class HelloApi extends Api {
  @override
  void build(Endpoints endpoints) {
    endpoints.get('/hello', _hello);
  }

  dynamic _hello(ServerContext context, MinervaRequest request) {
    return 'Hello, world!';
  }
}

class ApisBuilder extends MinervaApisBuilder {
  @override
  List<Api> build() {
    var apis = <Api>[];

    apis.add(HelloApi());

    return apis;
  }
}
```

### Тело запроса

Получить доступ к к телу запроса вы можете через поле `body` экземпляра класса `MinervaRequest`. Поле `body` предоставляет доступ к экземпляру класса `RequestBody`.

Изначально оно представлено в виде байт (поле `data`), однако есть методы для попытки представления его в виде:

- `текста`. Для этого используется метод `asText`;
- `json`. Для этого используется метод `asJson`;
- `form`. Для этого используется метод `asForm`.

#### FormData

Метод `asForm` экземпляра класса `RequestBody` возвращает `Future`, которое вернет экземпляр класса `FormData`.

Экземпляр класса `FormData` содержит поле `data`. Это `Map<String, FormDataValue>` где `String` это имя поля формы, а `FormDataValue` может быть 2 типов:

- `FormDataString` - это поле формы представляющий собой значение в виде строки;
- `FormDataFile` - это поле формы содержащее файл.

### Параметры пути

Путь к конечной точке в `Minerva` может содержать параметры вида: `/user/:id`. Во время поиска конечной точки для поступившего пути идет сапоставления соответствия пути пути заданному шаблону параметров.

Получить доступ к значениям параметров пути вы можете при помощи поля `pathParameters` экземпляра класса `MinervaRequest`.

Шаблон параметра пути так же может содержать его тип, тип может быть `int` или `double`. Пример задачи параметров пути с указанием типа: `/user/int:id`.

Так же шаблон параметра пути может содержать регулярное выражение. Пример задачи параметров пути с указанием регулярного выражения: `/user/:id([0-9])`.

Пример создания конечной точки с параметрами пути, использования параметров пути:

```dart
class EndpointsBuilder extends MinervaEndpointsBuilder {
  @override
  void build(Endpoints endpoints) {
    endpoints.get('/user/int:id', (context, request) {
      var id = request.pathParameters['id'];

      return 'User with id: $id.';
    });
  }
}
```

### Фильтр запроса

В `Minerva` вы можете задать фильтр запроса, который проверит `content-type`, наличие параметров пути/полей в json/полей в form, а так же соответствие их определенным типам данных. Если запрос не соответствует фильтру, то вы не получите ошибку не соответствия данных, `Minerva` будет считать что конечная точка не подходит для обработки запроса, в случае отсутствия конечных точек способных обработать запросы вы получите ошибку `404`.

Фильтр задается при помощи необязательного параметра `filter` при создании конечной точки.

Доступные типы фильтрации:

- проверка `content-type` заголовка;
- проверка параметров запроса, их имен, а так же типов данных;
- проверка тела запроса на то является ли он json, проверка имен json полей, а так же типов данных;
- проверка тела запроса на то является ли он формой, проверка имен полей формы, а так же типов данных.

Пример использования фильтра запросов, фильтрация запросов по наличию параметра запроса и соответствия его типу данных int:

```dart
class EndpointsBuilder extends MinervaEndpointsBuilder {
  @override
  void build(Endpoints endpoints) {
    endpoints.get('/user', (context, request) {
      var id = request.uri.queryParameters['id'] as int;

      return 'User with id: $id.';
    },
        filter: Filter(
            queryParameters: QueryParametersFilter(parameters: [
          QueryParameter(name: 'id', type: QueryParameterType.int)
        ])));
  }
}
```

### Веб-сокеты

В `Minerva` вы можете создавать конечные точки для обработки веб сокет подключений.

Запросы предполагающие веб сокет подключения не обрабатываются в конвейере обработки запросов, а сразу сапоставляются с конечными точками.

Пример создания конечной точки для обработки веб сокет подключения:

```dart
class EndpointsBuilder extends MinervaEndpointsBuilder {
  @override
  void build(Endpoints endpoints) {
    endpoints.ws('/hello', (context, socket) async {
      socket.add('Hello, world!');

      await socket.close();
    });
  }
}
```

# Аутентефикация

`Minerva` содержит вспомогательные средства для работы с JWT аутентефикация, а так же аутентефикация по кукам сессии.

## JWT

При создании конечной точки в `Minerva` при помощи необязательного параметра `authOptions` вы можете задать настройки `JWT` для этой конечной точки.

Настройки `JWT` задаются при помощи класса `JwtAuthOptions`, само наличие экземляра класса `JwtAuthOptions` будет предполагать что пользователь успешно прошел аутентефикацию.

Так же в классе `JwtAuthOptions` вы можете задать:

- `roles`. Роли, одной из которых должна соответствовать роль пользователя;
- `permissionLevel`. Роли могут содержать `permissionLevel`, это уровень доступа. Позволяет более гибко конфигурировать доступ к конечным точкам.

Пример создания конечной точки с заданными настройками JWT аутентефикации:

```dart
class EndpointsBuilder extends MinervaEndpointsBuilder {
  @override
  void build(Endpoints endpoints) {
    endpoints.get('/user/:id', (context, request) {
      var id = request.pathParameters['id'];

      return 'User with id: $id.';
    }, authOptions: AuthOptions(jwt: JwtAuthOptions(roles: ['User'])));
  }
}
```

`Minerva` содержит готовый промежуточный обработчик для `JWT` авторизации - `JwtAuthMiddleware`. В конвейере промежуточных обработчиков запроса он должен идти раньше чем `EndpointMiddleware`.

При создании экземпляра `JwtAuthMiddleware` вы должны задать обязательный параметр `tokenVerify`. Это обработчик, где вы прописываете логику проверки токена на валидность и должны вернуть `true` в случае, если пользователь авторизован, `false` в случае если пользователь не авторизован.

`Minerva` не содержит встроенных средств для работы с `JWT` токенами по причине наличия готовых сторонних пакетов для этого.

При создании экземпляра `JwtAuthMiddleware` вы можете задать параметр `getRole`. Это обработчик, где вы прописываете логику получения роли из токена. Обработчик должен вернуть экземпляр класса `Role`, с указанием имени роли. Так же для роли в можете задать `permissionLevel`.

Пример добавления `EndpointMiddleware` в конвейер обработки запроса:

```dart
class MiddlewaresBuilder extends MinervaMiddlewaresBuilder {
  @override
  List<Middleware> build() {
    var middlewares = <Middleware>[];

    middlewares.add(ErrorMiddleware());

    // Adds middleware for working with JWT.
    middlewares
        .add(JwtAuthMiddleware(tokenVerify: tokenVerify, getRole: getRole));

    middlewares.add(EndpointMiddleware());

    return middlewares;
  }

  bool tokenVerify(ServerContext context, String token) {
    // Check token and verify.

    return true;
  }

  Role getRole(ServerContext context, String token) {
    // Get info from token.

    return Role('User', permissionLevel: 1);
  }
}
```

## Куки

При создании конечной точки в `Minerva` при помощи необязательного параметра `authOptions` вы можете задать настройки авторизации по кукам для этой конечной точки.

Настройки авторизации по кукам задаются при помощи класса `CookieAuthOptions`, само наличие экземляра класса `CookieAuthOptions` будет предполагать что пользователь успешно прошел аутентефикацию.

Пример создания конечной точки с заданными настройками авторизации по кукам:

```dart
class EndpointsBuilder extends MinervaEndpointsBuilder {
  @override
  void build(Endpoints endpoints) {
    endpoints.get('/user/:id', (context, request) {
      var id = request.pathParameters['id'];

      return 'User with id: $id.';
    }, authOptions: AuthOptions(cookie: CookieAuthOptions()));
  }
}
```

`Minerva` содержит готовый промежуточный обработчик для авторизации по кукам - `CookieAuthMiddleware`. В конвейере промежуточных обработчиков запроса он должен идти раньше чем `EndpointMiddleware`.

При создании экземпляра `CookieAuthMiddleware` вы должны задать обязательный параметр `cookieIsAuthorized`. Это обработчик, где вы прописываете логику проверки куки и должны вернуть `true` в случае, если пользователь авторизован, `false` в случае если пользователь не авторизован.

Пример добавления `CookieAuthMiddleware` в конвейер обработки запроса:

```dart
class MiddlewaresBuilder extends MinervaMiddlewaresBuilder {
  @override
  List<Middleware> build() {
    var middlewares = <Middleware>[];

    middlewares.add(ErrorMiddleware());

    middlewares
        .add(CookieAuthMiddleware(isAuthorized: isAuthorized));

    middlewares.add(EndpointMiddleware());

    return middlewares;
  }

  bool isAuthorized(ServerContext context, List<Cookie> cookie) {
    // Check cookies

    return true;
  }
}
```

# Промежуточные обработчики

`Minerva` обрабатывает входящие запросы при помощи конвейера промежуточных обработчиков.

## Готовые промежуточные обработчики

`Minerva` содержит ряд готовых промежуточных обработчиков:

- `CookieAuthMiddleware` - может быть использован для проверки авторизации по кукам;
- `JwtAuthMiddleware` - может быть использован для проверки JWT авторизации;
- `ErrorMiddleware` - используется для обработки ошибок возникших в последующих промежуточных обработчиках в конвейере;
- `EndpointMiddleware` - используется для сапоставления входящего запроса с заданными в `Minerva` конечными точками. Должен быть последним в конвейере;
- `StaticFilesMiddleware` - может быть использован для организации раздачи статических файлов;
- `RedirectionMiddleware` - может быть использован для организации перенаправлений, с учетом наличия соответствующих прав доступа. При помощи этого обработчика к примеру можно реализовать gateway микросервис.

## Создание собственных промежуточных обработчиков

Вы можете создавать собственные промежуточные обработчики.

Каждый промежуточный обработчик наследуется от класса `Middleware`. Создавая производный от класса `Middleware`, вам необходимо реализовать в производном классе метод `handle`. В этом методы вам доступен экземляр класса `MiddlewareContext`, с его помощью вы можете получать доступ к конечным точкам, контексту сервера, а так же к входящему запросу. Каждый промежуточный обработчик должен либо обработать запрос самостоятельно, вернув некий результат, либо делегировать эту обязанность следующему промежуточному обработчику.

Пример создания собственного промежуточного обработчика:

```dart
class TestMiddleware extends Middleware {
  @override
  dynamic handle(MiddlewareContext context, MiddlewarePipelineNode? next) {
    print('Hello, middleware world!');

    if (next != null) {
      return next.handle(context);
    } else {
      return NotFoundResult();
    }
  }
}
```

Созданный в примере промежуточный обработчик будет печатать сообщение `'Hello, middleware world!'`, а так же проверять существует ли следующий промежуточный обработчик в конвейере. Если он существует, он делегирует обработку запроса ему, а если он отсутствует, то он вернет ошибку `404`.

# Статические файлы

`Minerva` содержит промежуточный обработчик для организации доступа к статическим файла - `StaticFilesMiddleware`.

При создании `StaticFilesMiddleware` вы можете задать следующие настройки:

- `directory`. Обязательный параметр. Путь к папке задается относительно папки проекта;
- `path`. Обязательный параметр. Путь по которому промежуточный обработчик будет пытаться сапоставить запрос, с статическими файлами;
- `root`. Необязательный параметр. Указывает относительно указанной `directory` путь к файлу, который будет отдаваться, если путь запроса будет соответствовать `path`, не не будет содерджать дальнейшего пути указывающего на необходимый файл.

Разберем пример создания промежуточного обработчика для организации доступа к статическим файлам.

Содержимое `MiddlewaresBuilder`:

```dart
class MiddlewaresBuilder extends MinervaMiddlewaresBuilder {
  @override
  List<Middleware> build() {
    var middlewares = <Middleware>[];

    middlewares.add(ErrorMiddleware());

    middlewares.add(StaticFilesMiddleware(
        directory: '/wwwroot', path: '/wwwroot', root: 'index.html'));

    middlewares.add(EndpointMiddleware());

    return middlewares;
  }
}
```

Содержимое файла `appsetting.json`:

```dart
{
    "debug": {
        "compile-type": "JIT",
        "host": "127.0.0.1",
        "port": 5000
    },
    "release": {
        "compile-type": "AOT",
        "host": "0.0.0.0",
        "port": 8080
    },
    "assets": [
        "/wwwroot"
    ]
}
```

Структура папки `wwwroot`:

- `images`;
  - `cat.jpg`;
- `index.html`;
- `some_file.txt`;

В приведенном примере, собрав проект в `debug` сборке, мы можем получить доступ к файлу `cat.jpg` по пути `http://127.0.0.1:5000/wwwroot/images/cat.jpg`.

# Внедрение зависимостей

`Minerva` для внедрения зависимостей в каждый экземпляр сервера использует классы производные от класса `MinervaServerBuilder`.

Из встроенных средств для внедрения зависимостей `Minerva` содержит только `ServerStore`. Это `key-value` коллекция, к которой вы можете получить доступ при помощи экземпляра `ServerContext`.

В экосистеме `Dart` существуют хорошие пакеты для внедрения зависимостей которыми вы можете воспользоваться (к примеру [get_it](https://pub.dev/packages/get_it)), прописав логику внедрения зависимостей в классе производном от класса `MinervaServerBuilder`.

# Агенты

В `Minerva` многопоточность исполнения запросов достигается развертыванием экземпляра сервера в отдельных изолятах.

Для организации доступа к общим данным из разных экземпляров сервера используются агенты. Это сущности исполняющиеся в отдельных изолятах, могут иметь собственное состояние, принимать запросы. Стоит учитывать что агенты разворачиваются в отдельных изолятах и при обращении к ним мы получаем потери производительности на перессылке сообщений между изолятами. Агентов стоит использовать только тогда, когда специфика реализуемой нами логики требует наличия некого общего состояния, между различными экземплярами сервера.

Каждый агент имеет собственное уникальное имя конфигурируемое при запуске сервера, по которому вы можете в дальнейшем получить коннектор к этому агенту.

## Создение собственных агентов

Все классы агентов в `Minerva` являются производными от класса `Agent`.

Агенты имеют методы:

- `initialize`. Метод срабатывает при стартовой инициализации сервера. С его помощью вы должны открывать подключения, инициализировать ресурсы и т.д.;
- `call`. Метод обрабатывает call обращения к агенту. Call обращение означает что агент должен прислать отправителю некий ответ;
- `cast`. Метод обрабатывает cast обращения к агенту. Cast обращение означает что агент не присылает отправителю ответ, а отправитель не дожидается результатов cast обращения;
- `dispose`. Метод срабатывает при уничтожении агента.

Как вы могли заметить есть 2 типа обращений к агенту:

- `call`. С ответом;
- `cast`. Без ответа.

При каждом обращении к агенту мы отсылаем ему `action`, в соответствии с которым он уже и выполняет некое действие, а так же можем прислать некие данные.

Рассмотрим простой пример создания агента, который хранит состояние счетчика, а так же создадим конечные точки, которые взаимодействуют с этим состоянием.

Создание класса агента:

```dart
class CounterAgent extends Agent {
  int _counter = 0;

  @override
  dynamic call(String action, Map<String, dynamic> data) {
    switch (action) {
      case ('get'):
        return _counter;
    }
  }

  @override
  void cast(String action, Map<String, dynamic> data) {
    switch (action) {
      case ('increment'):
        _counter++;
    }
  }
}
```

Конфигурирование агентов, создание агента с именем 'counter':

```dart
class AgentsBuilder extends MinervaAgentsBuilder {
  @override
  List<AgentData> build() {
    var agents = <AgentData>[];

    agents.add(AgentData('counter', CounterAgent()));

    return agents;
  }
}
```

Создание конечных точек:

```dart
class EndpointsBuilder extends MinervaEndpointsBuilder {
  @override
  void build(Endpoints endpoints) {
    endpoints.get('/counter/get', (context, request) async {
      var counter = await context.connectors['counter']!.call('get');

      return 'Counter state: $counter.';
    });

    endpoints.post('/counter/increment', (context, request) {
      context.connectors['counter']!.cast('increment');
    });
  }
}
```

Таким образом мы создали 2 конечные точки, и в каком бы из экземпляров сервера на обрабатывался входящий запрос, они будут взаимодействовать с одним состоянием счетчика.

# Логирование

`Minerva` содержит возможности логировани, а так же создания собственных логеров.

Логи в `Minerva` делятся на следующие уровни:

- `info`;
- `debug`;
- `warning`;
- `error`;
- `critical`.

## Конвейер

Процесс логирования в `Minerva` организован в виде конвейера. При конфигурировании сервера вы можете задать несколько логеров, которые будут участвовать в процессе логирования.

## Готовые логеры

`Minerva` содержит готовые логеры:

- `ConsoleLogger`. Логирует в консоль;
- `FileLogger`. Логирует в файл.

### Шаблоны логирования

Готовые логеры в `Minerva` позволяют задавать шаблон логирования.

По умолчанию шаблон логирования имеет вид: `'[&time] [&level] &message'`.

Шаблон логирования содержит подставляемые значения, такие как:

- `&time` - время логирования, без даты. Может быть задана как `&time(pattern)`, где `pattern` это шаблон из пакета [intl](https://pub.dev/packages/intl);
- `&date` - дата логирования, без времени. Может быть задана как `&date(pattern)`, где `pattern` это шаблон из пакета [intl](https://pub.dev/packages/intl);
- `&level` - уровень логирования;
- `&message` - сообщение.

### Логирование в файлы

Для логирования в файл `Minerva` содержит готовый логер `FileLogger`.

Этот логер работает в связке с готовым агентом `FileLoggerAgent`. Путь к файлу логирования вы можете задать при конфигурации агентов, при помощи параметра `logPath` класса `FileLoggerAgentData`. Путь к файлу логирования может быть задан как абсолютный, так и относительно папки проекта. Относительный путь должен начинаться с `~/`. Путь к файлу логирования по умолчанию - `~/log/log.log`. 

Для того чтобы использовать логер в файл, мы так же должны использовать `FileLoggerAgent`.

Рассмотрим пример конфигурированя логеров, а так же агентов для использования `FileLogger`.

Конфигурация логеров:

```dart
class LoggersBuilder extends MinervaLoggersBuilder {
  @override
  List<Logger> build() {
    var loggers = <Logger>[];

    loggers.add(FileLogger());

    return loggers;
  }
}
```

Конфигурация агентов:

```dart
class AgentsBuilder extends MinervaAgentsBuilder {
  @override
  List<AgentData> build() {
    var agents = <AgentData>[];

    agents.add(FileLoggerAgentData());

    return agents;
  }
}
```

## Конфигурация логирования

В `Minerva` при конфигурации сборки проекта, при помощи `appsetting.json` вы можете конфигурировать логирование. Вы можете для каждого конкретного логера указывать активные уровни логирования, для каждого типа сборки.

Каждый логер в `Minerva` имеет собственное имя. Для готовых логеров это:

- `ConsoleLogger` - `console`;
- `FileLogger` - `file`.

Если настройки для какого либо логера не указаны в `appsetting.json` это означает что для него доступны все уровни логирования.

Рассмотри пример где мы отключим в `release` сборке проекта только уровни `critical`, `error` для логера `console`.

Содержимое файла `appsetting.json`:

```dart
{
    "debug": {
        "compile-type": "JIT",
        "host": "127.0.0.1",
        "port": 5000
    },
    "release": {
        "compile-type": "AOT",
        "host": "0.0.0.0",
        "port": 8080,
        "logging": {
            "console": [
                "error",
                "critical"
            ]
        }
    }
}
```

## Создание собственных логеров

В `Minerva` вы можете создавать собственные логеры, для этого используется базовый класс `Logger`.

Каждый логер должен реализовать методы:

- `info`;
- `debug`;
- `warning`;
- `error`;
- `critical`.

Этим методы используются для логирования сообщений одноименных уровней логирования.

Логер как и любой другой компонент может иметь метод `initialize`, для осуществления отложенной инициализации.

Базовый класс `Logger` реализует метод `isLevelEnabled`, при помощи которого можно проверить, включен ли определенный уровень логирования в файле `appsetting.json` для текущего логера.

Пример создания собственного логера с именем `'custom'`:

```dart
class CustomLogger extends Logger {
  CustomLogger() : super('custom');

  @override
  void critical(object) {
    if (isLevelEnabled(LogLevel.critical)) {
      print('Level: critical, message: $object.');
    }
  }

  @override
  void debug(object) {
    if (isLevelEnabled(LogLevel.debug)) {
      print('Level: debug, message: $object.');
    }
  }

  @override
  void error(object) {
    if (isLevelEnabled(LogLevel.error)) {
      print('Level: error, message: $object.');
    }
  }

  @override
  void info(object) {
    if (isLevelEnabled(LogLevel.info)) {
      print('Level: info, message: $object.');
    }
  }

  @override
  void warning(object) {
    if (isLevelEnabled(LogLevel.warning)) {
      print('Level: warning, message: $object.');
    }
  }
}
```

# Менеджер конфигурации

Значения которые вы задаете при помощи параметра `values` в `appsetting.json` доступны вам во время работы сервера, вы можете получать к ним доступ и модифицировать. При сборке и запуске сервера вы взаимодействуете с `appsetting.json` текущего билда, а не всего проекта. Модификация значения так же происходит в рамках текущего билда, а не всего проекта.

Для работы с `values` текущего билда в `Minerva` доступен класс `ConfigurationManager`. Для загрузки значений из `appsetting.json` в текущий экземпляр `ConfigurationManager` вам доступен метод `load`. Далее вы можете модифицировать эти значения в рамках текущего экземпляра `ConfigurationManager`, а так же сохранить их в `appsetting.json` файл при помощи метода `save`.

Пример использования класса `ConfigurationManager`:

```dart
class EndpointsBuilder extends MinervaEndpointsBuilder {
  @override
  void build(Endpoints endpoints) {
    endpoints.get('/hello', (context, request) async {
      var configuration = ConfigurationManager();

      await configuration.load();

      return configuration['message'];
    });
  }
}
```

# Хэширование паролей

`Minerva` содержит функционал для хэширования паролей с заданной солью. Под капотом `Minerva` использует пакет [crypt](https://pub.dev/packages/crypt). Я решил включить этот функционал в фреймворк т.к прежде чем обнаружить актуальный пакет и удобный пакет для хэширования паролей попробовал не один пакет.

Хэширование паролей в `Minerva` доступно при помощи класса `PasswordSecurity`.

Пример хэширования пароля при помощи класса `PasswordSecurity`:

```dart
var security = PasswordSecurity();

var salt = 'cB9anFtmU9OCGl5n';

var password = 'some_passowrd';

var hash = security.hashPassword(password, salt: salt);
```

Генерация соли доступна при помощи метода `generateSalt` класса `PasswordSecurity`.

# Дорожная карта

- 🚧 Доделать обработку ошибок. Это ошибки в случае не верной конфигурации сервера, а так же выключение сервера в случае ошибок при инициализации компонентов;
- 🔜 Сделать документацию;
- 🔜 Сделать больше примеров;
- 🔜 Покрыть тестами;
- 🔜 Дополнить README файлы;
- 🔜 Создание обучающих видео;
- 🔜 Добавить тесты производительности;
- 🔜 Создать сайт с документацией.

Ну и конечно же исправление ошибок что будут обнаружены.

# Благодарность

Выражаю благодарность:

- моему [другу](https://vk.com/rubro.official) за создание логотипа.
